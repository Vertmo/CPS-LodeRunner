\documentclass{article}
\usepackage[a4paper, margin=1in]{geometry}
\usepackage{listings}

\title{CPS - Projet - LodeRunner\\Rapport}
\author{Basile Pesin, David Sreng\\Sorbonne Université}

\begin{document}
\maketitle

\section{Extensions}
La spécification des extensions décrites ci-dessous est disponible dans le fichier \textit{spec.pdf}, dans les sections du même nom.

\subsection{Améliorations des gardes}
Dans la spécification actuelle du jeu, les gardes ne sont pas très astucieux: ils refusent parfois de prendre une route allant en ligne droite jusqu'au joueur, et de faire certains mouvements assez simples. Sans aller jusqu'à programmer un algorithme de path-finding pour les gardes, on va améliorer quelques peu ces mouvements simples.

\subsubsection{Descendre les échelles, tomber des rails}
Deux des positions les plus facilement repérable dans lesquels les gardes sont bloqués est au sommet d'une échelle, ou accroché à un rail: en effet, dans la spécification actuelle, dans aucun de ces deux cas le comportement du garde n'est \textbf{Down} si le joueur se trouve en dessous de lui. On peut donc ajouter ces cas à la disjonction pour le \textbf{Down} dans les invariants du garde. On remarque que ces invariants sont déjà assez complexes, et l'ajout de ces cas spéciaux les rends de plus en plus difficiles à lire.

\subsubsection{Quitter les échelles}
Dernière faiblesse de nos gardes: ils ne savent pas quitter les échelles autrement qu'en ayant ``quelque chose sous les pieds'', que ce soit une case non-vide, ou un autre garde, alors que rien ne les empêcherai physiquement de quitter l'échelle si ils le souhaitaient. On décide donc de modifier l'IA des gardes pour qu'ils puissent se déplacer latéralement depuis une échelle, dans le cas ou ce déplacement permet de s'accrocher à un rail, ou de prendre pied sur une plateforme ou du métal. Encore une fois, cette modification s'applique dans les invariants en liens avec l'observateur \textrm{Behaviour}, et complique encore leur définitions en les rendants plus illisibles. De plus, il devient de plus en plus difficile de couvrir tous les sous-cas possibles pour un garde. On décide donc d'arrèter de modifier l'IA des gardes (de plus grosses modifications, comme un algorithme de pathfinding demanderaient sans doute une réécriture complète des invariants de \textrm{Behaviour}, ce pourquoi on a malheureusement pas le temps).

\subsubsection{Un pas sur deux}
Après toutes ces améliorations faites aux gardes, ceux-ci deviennent de plus en plus dangereux pour le joueur. Pour contrebalancer ce danger, on décide d'affaiblir considérablement les gardes en divisant par deux leur capacité d'action: autrement dit, les gardes n'agissent plus qu'un \textrm{step} de l'\textrm{Engine} sur deux, plutôt que tous les \textrm{step}. Pour cela, on doit modifier le service \textrm{Engine} plutôt que le service \textrm{Guard}, en introduisant un nouvel observateur \textrm{GuardTurn: [Engine] $\rightarrow$ boolean} qui s'inverse à chaque \textrm{step}. Le \textrm{Guard::step} n'est alors déclenché que si cet observateur est vrai. On observe que modifier l'appel des \textrm{step} de cette façon modifie double aussi le temps potentiel passé dans un trou par le garde (puisque \textrm{Guard::TimeInHole} augmente deux fois moins vite), et donc diminue les chances du garde de se sortir du trou. On pourrait si on voulait tout simplement diviser par 2 le seuil au delà duquel le garde sort du trou, mais cet équilibrage nous paraît correct.

\end{document}

\documentclass{article}
\usepackage[a4paper,margin=1in]{geometry}
\usepackage{listings}

\title{CPS - Projet - LodeRunner\\Rapport}
\author{Basile Pesin, David Sreng\\Sorbonne Université}

\begin{document}
\maketitle

\section{Extensions}
La spécification des extensions décrites ci-dessous est disponible dans le fichier \textit{spec.pdf}, dans les sections du même nom.

\subsection{Améliorations des gardes}
Dans la spécification actuelle du jeu, les gardes ne sont pas très astucieux: ils refusent parfois de prendre une route allant en ligne droite jusqu'au joueur, et de faire certains mouvements assez simples. Sans aller jusqu'à programmer un algorithme de path-finding pour les gardes, on va améliorer quelques peu ces mouvements simples.

\subsubsection{Descendre les échelles, tomber des rails}
Deux des positions les plus facilement repérable dans lesquels les gardes sont bloqués est au sommet d'une échelle, ou accroché à un rail: en effet, dans la spécification actuelle, dans aucun de ces deux cas le comportement du garde n'est \textbf{Down} si le joueur se trouve en dessous de lui. On peut donc ajouter ces cas à la disjonction pour le \textbf{Down} dans les invariants du garde. On remarque que ces invariants sont déjà assez complexes, et l'ajout de ces cas spéciaux les rends de plus en plus difficiles à lire.

\subsubsection{Quitter les échelles}
Dernière faiblesse de nos gardes: ils ne savent pas quitter les échelles autrement qu'en ayant ``quelque chose sous les pieds'', que ce soit une case non-vide, ou un autre garde, alors que rien ne les empêcherai physiquement de quitter l'échelle si ils le souhaitaient. On décide donc de modifier l'IA des gardes pour qu'ils puissent se déplacer latéralement depuis une échelle, dans le cas ou ce déplacement permet de s'accrocher à un rail, ou de prendre pied sur une plateforme ou du métal. Encore une fois, cette modification s'applique dans les invariants en liens avec l'observateur \textrm{Behaviour}, et complique encore leur définitions en les rendants plus illisibles. De plus, il devient de plus en plus difficile de couvrir tous les sous-cas possibles pour un garde. On décide donc d'arrèter de modifier l'IA des gardes (de plus grosses modifications, comme un algorithme de pathfinding demanderaient sans doute une réécriture complète des invariants de \textrm{Behaviour}, ce pourquoi on a malheureusement pas le temps).

\subsubsection{Un pas sur deux}
Après toutes ces améliorations faites aux gardes, ceux-ci deviennent de plus en plus dangereux pour le joueur. Pour contrebalancer ce danger, on décide d'affaiblir considérablement les gardes en divisant par deux leur capacité d'action: autrement dit, les gardes n'agissent plus qu'un \textrm{step} de l'\textrm{Engine} sur deux, plutôt que tous les \textrm{step}. Pour cela, on doit modifier le service \textrm{Engine} plutôt que le service \textrm{Guard}, en introduisant un nouvel observateur \textrm{GuardTurn: [Engine] $\rightarrow$ boolean} qui s'inverse à chaque \textrm{step}. Le \textrm{Guard::step} n'est alors déclenché que si cet observateur est vrai. On observe que modifier l'appel des \textrm{step} de cette façon modifie double aussi le temps potentiel passé dans un trou par le garde (puisque \textrm{Guard::TimeInHole} augmente deux fois moins vite), et donc diminue les chances du garde de se sortir du trou. On pourrait si on voulait tout simplement diviser par 2 le seuil au delà duquel le garde sort du trou, mais cet équilibrage nous paraît correct.

\subsection{Plus de cellules}
Dans cette extension, on décide de complexifier le gameplay de notre jeu en ajoutant de nouvelles variantes de cellules permettant de créer des puzzle plus complexes.

\subsubsection{Pièges}
La première case qu'on ajoute est assez simple: il s'agit d'un piège, c'est à dire une case \textbf{TRP} ressemblant au premier abord à une plateforme normale, mais se dérobant dès que le joueur (ou un garde) marche dessus.
L'implémentation du piège nécessite principalement des modifications dans le service \textrm{Screen}, ou l'on ajoute un nouvel opérateur \textrm{TriggerTrap: [Screen] $\times$ int $\times$ int $\rightarrow$ [Screen]} déclenchant un des pièges, c'est à dire transformant la case \textbf{TRP} en case \textbf{EMP}. De plus, il faut aussi effectuer des modifications au niveau du service \textrm{Engine}, principalement dans les post-conditions de \textrm{Step}, pour que le passage du joueur ou d'un garde au dessus de la case du piège déclenche effectivement celui-ci. Il est intéressant de remarquer que, pour conserver la cohérence de la spécification, le piège se déclenche après le \textrm{Step} du joueur ou garde qui l'a déclenché (sinon il y aurait une confusion sur le contenu de la case sous les pieds du personnage à l'instant du déclenchement).\\

On note également des modifications dans les services \textrm{Character} et \textrm{Guard}, pour que les pièges soient considérés comme des plateformes avant d'être déclenchés (entre autres pour qu'ils bloquent un mouvement latéral). Ces changements étant peu intéressants d'un point de vue de la spécification, on n'a pas pris la peine de recopier les nouvelles spécifications de ces services dans le fichier \textit{spec.pdf}.

\subsubsection{Portails}
Le deuxième type de case qu'on ajoute n'est en fait pas (pour des raisons de spécifications sur lesquelles on reviendra) en fait pas vraiment un type de case. Il s'agit d'un système de portails unidirectionnels (certains portails bleus sont des portails d'entrées, d'autres oranges sont des portails de sorties) que le joueur peut traverser. Les portails fonctionnent par paires, de sortes qu'entrer dans un portail bleu donné amènera toujours au même portail orange correspondant. Cependant, la correspondance des paires de portails n'est pas clairement marquée sur l'écran de jeu, de sorte que le joueur ait à deviner (ou à se souvenir) du portail correspondant à celui ou il veut se rendre, à la façon d'un jeu de memory.\\

Comme les cases sont implémentées par une énumération (et que nous ne souhaitions pas modifier cette implémentation, puisqu'il aurait alors fallu réécrire une bonne partie de la spécification et de l'implémentation), on ne pouvait pas stocker dans une case l'information des coordonnées du portail de sortie. On a donc décidé de stocker les paires de portails comme une information supplémentaire pour l'\textrm{Engine}. On peu donc un accéder avec l'observateur \textrm{Portals: [Engine] $\rightarrow$ PortalPair} (le type de données \textrm{PortalPair} contient tout simplement les coordonnées du portail d'entrée accessible avec \textrm{CoordPIn} et celles du portail de sortie avec \textrm{CoordPOut}.\\
On doit également modifier le constructeur \textrm{init} de \textrm{Engine} pour lui passer en plus des paramètre précédant un ensemble de \textrm{PortalPair}. Cela nous oblige à modifier pas mal du code utilisant ce \textrm{init} (on aurait aussi pu introduire un nouvel \textrm{init}) plutôt que de modifier l'existant, mais cela aurait compliqué la spécification).\\
Enfin, on ajoute au \textrm{Player} un opérateur \textrm{Teleport: [Player] $\times$ int $\times$ int $\rightarrow$ [Player]} qui comme son nom l'indique téléporte le joueur, c'est à dire le déplace instantanément aux coordonnées spécifiées. Cet opérateur est appelé par \textrm{Engine} à la place de \textrm{Player::step} quand le joueur se trouve sur une case contenant une entrée de portail.

\end{document}
